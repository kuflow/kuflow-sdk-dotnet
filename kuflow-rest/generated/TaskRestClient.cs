// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Kuflow.Rest.Models;

namespace Kuflow.Rest
{
    internal partial class TaskRestClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> Initializes a new instance of TaskRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="clientDiagnostics"/> or <paramref name="pipeline"/> is null. </exception>
        public TaskRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint = null)
        {
            ClientDiagnostics = clientDiagnostics ?? throw new ArgumentNullException(nameof(clientDiagnostics));
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://api.kuflow.com/v2022-10-08");
        }

        internal HttpMessage CreateFindTasksRequest(int? size, int? page, IEnumerable<string> sort, IEnumerable<Guid> processId, IEnumerable<TaskState> state, IEnumerable<string> taskDefinitionCode)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks", false);
            if (size != null)
            {
                uri.AppendQuery("size", size.Value, true);
            }
            if (page != null)
            {
                uri.AppendQuery("page", page.Value, true);
            }
            if (sort != null && Optional.IsCollectionDefined(sort))
            {
                foreach (var param in sort)
                {
                    uri.AppendQuery("sort", param, true);
                }
            }
            if (processId != null && Optional.IsCollectionDefined(processId))
            {
                foreach (var param in processId)
                {
                    uri.AppendQuery("processId", param, true);
                }
            }
            if (state != null && Optional.IsCollectionDefined(state))
            {
                foreach (var param in state)
                {
                    uri.AppendQuery("state", param.ToSerialString(), true);
                }
            }
            if (taskDefinitionCode != null && Optional.IsCollectionDefined(taskDefinitionCode))
            {
                foreach (var param in taskDefinitionCode)
                {
                    uri.AppendQuery("taskDefinitionCode", param, true);
                }
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Find all accessible Tasks. </summary>
        /// <param name="size"> The number of records returned within a single API call. </param>
        /// <param name="page"> The page number of the current page in the returned records, 0 is the first page. </param>
        /// <param name="sort">
        /// Sorting criteria in the format: property{,asc|desc}. Example: createdAt,desc
        /// 
        /// Default sort order is ascending. Multiple sort criteria are supported.
        /// 
        /// Please refer to the method description for supported properties.
        /// 
        /// </param>
        /// <param name="processId"> Filter by an array of process ids. </param>
        /// <param name="state"> Filter by an array of task states. </param>
        /// <param name="taskDefinitionCode"> Filter by an array of task definition codes. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// List all Tasks that have been created and the credentials has access.
        /// 
        /// Available sort query values: id, createdAt, lastModifiedAt, claimedAt, completedAt, cancelledAt
        /// 
        /// </remarks>
        public async Task<Response<TaskPage>> FindTasksAsync(int? size = null, int? page = null, IEnumerable<string> sort = null, IEnumerable<Guid> processId = null, IEnumerable<TaskState> state = null, IEnumerable<string> taskDefinitionCode = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateFindTasksRequest(size, page, sort, processId, state, taskDefinitionCode);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TaskPage value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = TaskPage.DeserializeTaskPage(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Find all accessible Tasks. </summary>
        /// <param name="size"> The number of records returned within a single API call. </param>
        /// <param name="page"> The page number of the current page in the returned records, 0 is the first page. </param>
        /// <param name="sort">
        /// Sorting criteria in the format: property{,asc|desc}. Example: createdAt,desc
        /// 
        /// Default sort order is ascending. Multiple sort criteria are supported.
        /// 
        /// Please refer to the method description for supported properties.
        /// 
        /// </param>
        /// <param name="processId"> Filter by an array of process ids. </param>
        /// <param name="state"> Filter by an array of task states. </param>
        /// <param name="taskDefinitionCode"> Filter by an array of task definition codes. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// List all Tasks that have been created and the credentials has access.
        /// 
        /// Available sort query values: id, createdAt, lastModifiedAt, claimedAt, completedAt, cancelledAt
        /// 
        /// </remarks>
        public Response<TaskPage> FindTasks(int? size = null, int? page = null, IEnumerable<string> sort = null, IEnumerable<Guid> processId = null, IEnumerable<TaskState> state = null, IEnumerable<string> taskDefinitionCode = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateFindTasksRequest(size, page, sort, processId, state, taskDefinitionCode);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TaskPage value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = TaskPage.DeserializeTaskPage(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateCreateTaskRequest(Models.Task task, string activityToken)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks", false);
            if (activityToken != null)
            {
                uri.AppendQuery("activityToken", activityToken, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(task);
            request.Content = content;
            return message;
        }

        /// <summary> Create a new Task in the selected Process. </summary>
        /// <param name="task"> Task to be created. </param>
        /// <param name="activityToken"> When create a Kuflow Task backed with a Temporal.io servers, this value is required and must be set with the context task token of Temporal.io activity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="task"/> is null. </exception>
        /// <remarks>
        /// Create a Task and optionally fill its elements. We can fill in any type of element except documents.
        /// 
        /// If you want to add document type elements, you can pass a reference to an existing document type element indicating its &apos;uri&apos;. This will copy that document into the element. In case you want to add a new document, please use the corresponding API method.
        /// 
        /// If you want that the task created is claimed you can a valid owner using the following options:
        /// * If you know the `principal ID` you can assign it to `owner.id`
        /// * If you know the `user ID` you can assign it to `owner.user.id`
        /// * If you know the `user email` you can assign it to `owner.user.email`
        /// * If you know the `application ID` you can assign it to `owner.application.id`
        /// 
        /// If you want the method to be idempotent, please specify the `id` field in the request body.
        /// 
        /// </remarks>
        public async Task<Response<Models.Task>> CreateTaskAsync(Models.Task task, string activityToken = null, CancellationToken cancellationToken = default)
        {
            if (task == null)
            {
                throw new ArgumentNullException(nameof(task));
            }

            using var message = CreateCreateTaskRequest(task, activityToken);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    {
                        Models.Task value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create a new Task in the selected Process. </summary>
        /// <param name="task"> Task to be created. </param>
        /// <param name="activityToken"> When create a Kuflow Task backed with a Temporal.io servers, this value is required and must be set with the context task token of Temporal.io activity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="task"/> is null. </exception>
        /// <remarks>
        /// Create a Task and optionally fill its elements. We can fill in any type of element except documents.
        /// 
        /// If you want to add document type elements, you can pass a reference to an existing document type element indicating its &apos;uri&apos;. This will copy that document into the element. In case you want to add a new document, please use the corresponding API method.
        /// 
        /// If you want that the task created is claimed you can a valid owner using the following options:
        /// * If you know the `principal ID` you can assign it to `owner.id`
        /// * If you know the `user ID` you can assign it to `owner.user.id`
        /// * If you know the `user email` you can assign it to `owner.user.email`
        /// * If you know the `application ID` you can assign it to `owner.application.id`
        /// 
        /// If you want the method to be idempotent, please specify the `id` field in the request body.
        /// 
        /// </remarks>
        public Response<Models.Task> CreateTask(Models.Task task, string activityToken = null, CancellationToken cancellationToken = default)
        {
            if (task == null)
            {
                throw new ArgumentNullException(nameof(task));
            }

            using var message = CreateCreateTaskRequest(task, activityToken);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    {
                        Models.Task value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateRetrieveTaskRequest(Guid id)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(id, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Get a task given it ID. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Allow to get a task by ID. </remarks>
        public async Task<Response<Models.Task>> RetrieveTaskAsync(Guid id, CancellationToken cancellationToken = default)
        {
            using var message = CreateRetrieveTaskRequest(id);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a task given it ID. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Allow to get a task by ID. </remarks>
        public Response<Models.Task> RetrieveTask(Guid id, CancellationToken cancellationToken = default)
        {
            using var message = CreateRetrieveTaskRequest(id);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsTaskClaimRequest(Guid id)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/claim", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Claim a task. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Allow to claim a task. </remarks>
        public async Task<Response<Models.Task>> ActionsTaskClaimAsync(Guid id, CancellationToken cancellationToken = default)
        {
            using var message = CreateActionsTaskClaimRequest(id);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Claim a task. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Allow to claim a task. </remarks>
        public Response<Models.Task> ActionsTaskClaim(Guid id, CancellationToken cancellationToken = default)
        {
            using var message = CreateActionsTaskClaimRequest(id);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsTaskAssignRequest(Guid id, TaskAssignCommand command)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/assign", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(command);
            request.Content = content;
            return message;
        }

        /// <summary> Assign a task. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to change the task owner. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks> Allow to assign a task to a user or application. Only one option will be necessary. </remarks>
        public async Task<Response<Models.Task>> ActionsTaskAssignAsync(Guid id, TaskAssignCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsTaskAssignRequest(id, command);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Assign a task. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to change the task owner. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks> Allow to assign a task to a user or application. Only one option will be necessary. </remarks>
        public Response<Models.Task> ActionsTaskAssign(Guid id, TaskAssignCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsTaskAssignRequest(id, command);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsTaskSaveElementRequest(Guid id, TaskSaveElementCommand command)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/save-element", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(command);
            request.Content = content;
            return message;
        }

        /// <summary> Save an element. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to save an element. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Allow to save an element i.e., a field, a decision, a form, a principal or document.
        /// 
        /// In the case of document type elements, this method only allows references to be made to other existing document type elements for the purpose of copying that file into the element. To do this you need to pass a reference to the document using the &apos;uri&apos; attribute. In case you want to add a new document, please use the corresponding API method. If values already exist for the provided element code, it replaces them with the new ones, otherwise it creates them. The values of the previous elements that no longer exist will be deleted. To remove an element, use the appropriate API method.
        /// 
        /// </remarks>
        public async Task<Response<Models.Task>> ActionsTaskSaveElementAsync(Guid id, TaskSaveElementCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsTaskSaveElementRequest(id, command);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Save an element. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to save an element. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Allow to save an element i.e., a field, a decision, a form, a principal or document.
        /// 
        /// In the case of document type elements, this method only allows references to be made to other existing document type elements for the purpose of copying that file into the element. To do this you need to pass a reference to the document using the &apos;uri&apos; attribute. In case you want to add a new document, please use the corresponding API method. If values already exist for the provided element code, it replaces them with the new ones, otherwise it creates them. The values of the previous elements that no longer exist will be deleted. To remove an element, use the appropriate API method.
        /// 
        /// </remarks>
        public Response<Models.Task> ActionsTaskSaveElement(Guid id, TaskSaveElementCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsTaskSaveElementRequest(id, command);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsTaskSaveElementValueDocumentRequest(Guid id, string fileContentType, string fileName, string elementDefinitionCode, Stream file, Guid? elementValueId, bool? elementValueValid)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/save-element-value-document", false);
            uri.AppendQuery("fileContentType", fileContentType, true);
            uri.AppendQuery("fileName", fileName, true);
            uri.AppendQuery("elementDefinitionCode", elementDefinitionCode, true);
            if (elementValueId != null)
            {
                uri.AppendQuery("elementValueId", elementValueId.Value, true);
            }
            if (elementValueValid != null)
            {
                uri.AppendQuery("elementValueValid", elementValueValid.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/octet-stream");
            request.Content = RequestContent.Create(file);
            return message;
        }

        /// <summary> Save an element document. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="fileContentType"> Document content type. </param>
        /// <param name="fileName"> Document name. </param>
        /// <param name="elementDefinitionCode"> Element Definition Code. </param>
        /// <param name="file"> Command to save a document element value. </param>
        /// <param name="elementValueId"> Element Value ID. </param>
        /// <param name="elementValueValid"> Element Value ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileContentType"/>, <paramref name="fileName"/>, <paramref name="elementDefinitionCode"/> or <paramref name="file"/> is null. </exception>
        /// <remarks>
        /// Allow to save an element document uploading the content.
        /// 
        /// If it is a multiple element, and the ID referenced in the body does not exist or is empty, the document will be added to the element. If the element already exists (the ID referenced in the body corresponds to an existing one), it updates it.
        /// 
        /// </remarks>
        public async Task<Response<Models.Task>> ActionsTaskSaveElementValueDocumentAsync(Guid id, string fileContentType, string fileName, string elementDefinitionCode, Stream file, Guid? elementValueId = null, bool? elementValueValid = null, CancellationToken cancellationToken = default)
        {
            if (fileContentType == null)
            {
                throw new ArgumentNullException(nameof(fileContentType));
            }
            if (fileName == null)
            {
                throw new ArgumentNullException(nameof(fileName));
            }
            if (elementDefinitionCode == null)
            {
                throw new ArgumentNullException(nameof(elementDefinitionCode));
            }
            if (file == null)
            {
                throw new ArgumentNullException(nameof(file));
            }

            using var message = CreateActionsTaskSaveElementValueDocumentRequest(id, fileContentType, fileName, elementDefinitionCode, file, elementValueId, elementValueValid);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Save an element document. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="fileContentType"> Document content type. </param>
        /// <param name="fileName"> Document name. </param>
        /// <param name="elementDefinitionCode"> Element Definition Code. </param>
        /// <param name="file"> Command to save a document element value. </param>
        /// <param name="elementValueId"> Element Value ID. </param>
        /// <param name="elementValueValid"> Element Value ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileContentType"/>, <paramref name="fileName"/>, <paramref name="elementDefinitionCode"/> or <paramref name="file"/> is null. </exception>
        /// <remarks>
        /// Allow to save an element document uploading the content.
        /// 
        /// If it is a multiple element, and the ID referenced in the body does not exist or is empty, the document will be added to the element. If the element already exists (the ID referenced in the body corresponds to an existing one), it updates it.
        /// 
        /// </remarks>
        public Response<Models.Task> ActionsTaskSaveElementValueDocument(Guid id, string fileContentType, string fileName, string elementDefinitionCode, Stream file, Guid? elementValueId = null, bool? elementValueValid = null, CancellationToken cancellationToken = default)
        {
            if (fileContentType == null)
            {
                throw new ArgumentNullException(nameof(fileContentType));
            }
            if (fileName == null)
            {
                throw new ArgumentNullException(nameof(fileName));
            }
            if (elementDefinitionCode == null)
            {
                throw new ArgumentNullException(nameof(elementDefinitionCode));
            }
            if (file == null)
            {
                throw new ArgumentNullException(nameof(file));
            }

            using var message = CreateActionsTaskSaveElementValueDocumentRequest(id, fileContentType, fileName, elementDefinitionCode, file, elementValueId, elementValueValid);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsTaskDeleteElementRequest(Guid id, TaskDeleteElementCommand command)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/delete-element", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(command);
            request.Content = content;
            return message;
        }

        /// <summary> Delete an element by code. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to delete an element. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Allow to delete task element by specifying the item definition code.
        /// 
        /// Remove all the element values.
        /// 
        /// </remarks>
        public async Task<Response<Models.Task>> ActionsTaskDeleteElementAsync(Guid id, TaskDeleteElementCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsTaskDeleteElementRequest(id, command);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete an element by code. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to delete an element. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Allow to delete task element by specifying the item definition code.
        /// 
        /// Remove all the element values.
        /// 
        /// </remarks>
        public Response<Models.Task> ActionsTaskDeleteElement(Guid id, TaskDeleteElementCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsTaskDeleteElementRequest(id, command);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsTaskDeleteElementValueDocumentRequest(Guid id, TaskDeleteElementValueDocumentCommand command)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/delete-element-value-document", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(command);
            request.Content = content;
            return message;
        }

        /// <summary> Delete an element document value. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to delete a document elemente value. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Allow to delete a specific document from an element of document type using its id.
        /// 
        /// Note: If it is a multiple item, it will only delete the specified document. If it is a single element, in addition to the document, it will also delete the element.
        /// 
        /// </remarks>
        public async Task<Response<Models.Task>> ActionsTaskDeleteElementValueDocumentAsync(Guid id, TaskDeleteElementValueDocumentCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsTaskDeleteElementValueDocumentRequest(id, command);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete an element document value. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to delete a document elemente value. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Allow to delete a specific document from an element of document type using its id.
        /// 
        /// Note: If it is a multiple item, it will only delete the specified document. If it is a single element, in addition to the document, it will also delete the element.
        /// 
        /// </remarks>
        public Response<Models.Task> ActionsTaskDeleteElementValueDocument(Guid id, TaskDeleteElementValueDocumentCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsTaskDeleteElementValueDocumentRequest(id, command);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsTaskDownloadElementValueDocumentRequest(Guid id, Guid documentId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/download-element-value-document", false);
            uri.AppendQuery("documentId", documentId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/octet-stream, application/json");
            return message;
        }

        /// <summary> Download document. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="documentId"> Document ID to download. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Given a task, download a document from an element of document type. </remarks>
        public async Task<Response<Stream>> ActionsTaskDownloadElementValueDocumentAsync(Guid id, Guid documentId, CancellationToken cancellationToken = default)
        {
            using var message = CreateActionsTaskDownloadElementValueDocumentRequest(id, documentId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Download document. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="documentId"> Document ID to download. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Given a task, download a document from an element of document type. </remarks>
        public Response<Stream> ActionsTaskDownloadElementValueDocument(Guid id, Guid documentId, CancellationToken cancellationToken = default)
        {
            using var message = CreateActionsTaskDownloadElementValueDocumentRequest(id, documentId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsTaskDownloadElementValueRenderedRequest(Guid id, string elementDefinitionCode)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/download-element-value-form-rendered", false);
            uri.AppendQuery("elementDefinitionCode", elementDefinitionCode, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/pdf, application/zip, application/json");
            return message;
        }

        /// <summary> Download a Form rendered as PDF or Zip of PDFs (when the element is multiple). </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="elementDefinitionCode"> Element definition code of a Form Element to download. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="elementDefinitionCode"/> is null. </exception>
        /// <remarks>
        /// Given a task, generate a PDF from a Form type element with the data filled in, if any. If there are multiple form values, they are packed into a ZIP.
        /// 
        /// Important!: To use this feature, please contact to kuflow@kuflow.com
        /// 
        /// </remarks>
        public async Task<Response<Stream>> ActionsTaskDownloadElementValueRenderedAsync(Guid id, string elementDefinitionCode, CancellationToken cancellationToken = default)
        {
            if (elementDefinitionCode == null)
            {
                throw new ArgumentNullException(nameof(elementDefinitionCode));
            }

            using var message = CreateActionsTaskDownloadElementValueRenderedRequest(id, elementDefinitionCode);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Download a Form rendered as PDF or Zip of PDFs (when the element is multiple). </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="elementDefinitionCode"> Element definition code of a Form Element to download. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="elementDefinitionCode"/> is null. </exception>
        /// <remarks>
        /// Given a task, generate a PDF from a Form type element with the data filled in, if any. If there are multiple form values, they are packed into a ZIP.
        /// 
        /// Important!: To use this feature, please contact to kuflow@kuflow.com
        /// 
        /// </remarks>
        public Response<Stream> ActionsTaskDownloadElementValueRendered(Guid id, string elementDefinitionCode, CancellationToken cancellationToken = default)
        {
            if (elementDefinitionCode == null)
            {
                throw new ArgumentNullException(nameof(elementDefinitionCode));
            }

            using var message = CreateActionsTaskDownloadElementValueRenderedRequest(id, elementDefinitionCode);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsTaskCompleteRequest(Guid id)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/complete", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Complete a task. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Allow to complete a claimed task by the principal. </remarks>
        public async Task<Response<Models.Task>> ActionsTaskCompleteAsync(Guid id, CancellationToken cancellationToken = default)
        {
            using var message = CreateActionsTaskCompleteRequest(id);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Complete a task. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Allow to complete a claimed task by the principal. </remarks>
        public Response<Models.Task> ActionsTaskComplete(Guid id, CancellationToken cancellationToken = default)
        {
            using var message = CreateActionsTaskCompleteRequest(id);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsTaskAppendLogRequest(Guid id, Log log)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/append-log", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(log);
            request.Content = content;
            return message;
        }

        /// <summary> Append a log to the task. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="log"> Log to be created. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="log"/> is null. </exception>
        /// <remarks>
        /// A log entry is added to the task. If the number of log entries is reached, the oldest log entry is removed.
        /// 
        /// </remarks>
        public async Task<Response<Models.Task>> ActionsTaskAppendLogAsync(Guid id, Log log, CancellationToken cancellationToken = default)
        {
            if (log == null)
            {
                throw new ArgumentNullException(nameof(log));
            }

            using var message = CreateActionsTaskAppendLogRequest(id, log);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Append a log to the task. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="log"> Log to be created. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="log"/> is null. </exception>
        /// <remarks>
        /// A log entry is added to the task. If the number of log entries is reached, the oldest log entry is removed.
        /// 
        /// </remarks>
        public Response<Models.Task> ActionsTaskAppendLog(Guid id, Log log, CancellationToken cancellationToken = default)
        {
            if (log == null)
            {
                throw new ArgumentNullException(nameof(log));
            }

            using var message = CreateActionsTaskAppendLogRequest(id, log);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Models.Task value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Models.Task.DeserializeTask(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}
