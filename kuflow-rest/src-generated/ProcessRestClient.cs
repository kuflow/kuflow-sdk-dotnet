// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using KuFlow.Rest.Models;

namespace KuFlow.Rest
{
    internal partial class ProcessRestClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> Initializes a new instance of ProcessRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="clientDiagnostics"/> or <paramref name="pipeline"/> is null. </exception>
        public ProcessRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint = null)
        {
            ClientDiagnostics = clientDiagnostics ?? throw new ArgumentNullException(nameof(clientDiagnostics));
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://api.kuflow.com/v2022-10-08");
        }

        internal HttpMessage CreateFindProcessesRequest(int? size, int? page, IEnumerable<string> sort, IEnumerable<Guid> tenantId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/processes", false);
            if (size != null)
            {
                uri.AppendQuery("size", size.Value, true);
            }
            if (page != null)
            {
                uri.AppendQuery("page", page.Value, true);
            }
            if (sort != null && Optional.IsCollectionDefined(sort))
            {
                foreach (var param in sort)
                {
                    uri.AppendQuery("sort", param, true);
                }
            }
            if (tenantId != null && Optional.IsCollectionDefined(tenantId))
            {
                foreach (var param in tenantId)
                {
                    uri.AppendQuery("tenantId", param, true);
                }
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Find all accessible Processes. </summary>
        /// <param name="size"> The number of records returned within a single API call. </param>
        /// <param name="page"> The page number of the current page in the returned records, 0 is the first page. </param>
        /// <param name="sort">
        /// Sorting criteria in the format: property{,asc|desc}. Example: createdAt,desc
        ///
        /// Default sort order is ascending. Multiple sort criteria are supported.
        ///
        /// Please refer to the method description for supported properties.
        ///
        /// </param>
        /// <param name="tenantId"> Filter by tenantId. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// List all the Processes that have been created and the credentials has access.
        ///
        /// Available sort query values: id, createdAt, lastModifiedAt
        ///
        /// </remarks>
        public async Task<Response<ProcessPage>> FindProcessesAsync(int? size = null, int? page = null, IEnumerable<string> sort = null, IEnumerable<Guid> tenantId = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateFindProcessesRequest(size, page, sort, tenantId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ProcessPage value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ProcessPage.DeserializeProcessPage(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Find all accessible Processes. </summary>
        /// <param name="size"> The number of records returned within a single API call. </param>
        /// <param name="page"> The page number of the current page in the returned records, 0 is the first page. </param>
        /// <param name="sort">
        /// Sorting criteria in the format: property{,asc|desc}. Example: createdAt,desc
        ///
        /// Default sort order is ascending. Multiple sort criteria are supported.
        ///
        /// Please refer to the method description for supported properties.
        ///
        /// </param>
        /// <param name="tenantId"> Filter by tenantId. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// List all the Processes that have been created and the credentials has access.
        ///
        /// Available sort query values: id, createdAt, lastModifiedAt
        ///
        /// </remarks>
        public Response<ProcessPage> FindProcesses(int? size = null, int? page = null, IEnumerable<string> sort = null, IEnumerable<Guid> tenantId = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateFindProcessesRequest(size, page, sort, tenantId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ProcessPage value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ProcessPage.DeserializeProcessPage(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateCreateProcessRequest(Process process)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/processes", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(process);
            request.Content = content;
            return message;
        }

        /// <summary> Create a new process. </summary>
        /// <param name="process"> Process to create. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="process"/> is null. </exception>
        /// <remarks>
        /// Creates a process. This option has direct correspondence to the action of starting a process in the Kuflow GUI.
        ///
        /// When a process is created, the current user is assigned as the process initiator, if you want to change it, you can pass a valid initiator using the following options:
        ///
        /// * If you know the `principal ID` you can assign it to `initiator.id`
        /// * If you know the `user ID` you can assign it to `initiator.user.id`
        /// * If you know the `user email` you can assign it to `initiator.user.email`
        /// * If you know the `application ID` you can assign it to `initiator.application.id`
        ///
        /// If you want the method to be idempotent, please specify the `id` field in the request body.
        ///
        /// </remarks>
        public async Task<Response<Process>> CreateProcessAsync(Process process, CancellationToken cancellationToken = default)
        {
            if (process == null)
            {
                throw new ArgumentNullException(nameof(process));
            }

            using var message = CreateCreateProcessRequest(process);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    {
                        Process value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create a new process. </summary>
        /// <param name="process"> Process to create. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="process"/> is null. </exception>
        /// <remarks>
        /// Creates a process. This option has direct correspondence to the action of starting a process in the Kuflow GUI.
        ///
        /// When a process is created, the current user is assigned as the process initiator, if you want to change it, you can pass a valid initiator using the following options:
        ///
        /// * If you know the `principal ID` you can assign it to `initiator.id`
        /// * If you know the `user ID` you can assign it to `initiator.user.id`
        /// * If you know the `user email` you can assign it to `initiator.user.email`
        /// * If you know the `application ID` you can assign it to `initiator.application.id`
        ///
        /// If you want the method to be idempotent, please specify the `id` field in the request body.
        ///
        /// </remarks>
        public Response<Process> CreateProcess(Process process, CancellationToken cancellationToken = default)
        {
            if (process == null)
            {
                throw new ArgumentNullException(nameof(process));
            }

            using var message = CreateCreateProcessRequest(process);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    {
                        Process value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateRetrieveProcessRequest(Guid id)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/processes/", false);
            uri.AppendPath(id, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Get a Process by ID. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Returns the requested Process when has access to do it. </remarks>
        public async Task<Response<Process>> RetrieveProcessAsync(Guid id, CancellationToken cancellationToken = default)
        {
            using var message = CreateRetrieveProcessRequest(id);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Process by ID. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Returns the requested Process when has access to do it. </remarks>
        public Response<Process> RetrieveProcess(Guid id, CancellationToken cancellationToken = default)
        {
            using var message = CreateRetrieveProcessRequest(id);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsProcessChangeInitiatorRequest(Guid id, ProcessChangeInitiatorCommand command)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/processes/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/change-initiator", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(command);
            request.Content = content;
            return message;
        }

        /// <summary> Change process initiator. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to change the process initiator. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Change the current initiator of a process.
        ///
        /// Allows you to choose a user (by email or principal identifier) or an application (principal identifier).
        /// Only one option will be necessary.
        ///
        /// </remarks>
        public async Task<Response<Process>> ActionsProcessChangeInitiatorAsync(Guid id, ProcessChangeInitiatorCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsProcessChangeInitiatorRequest(id, command);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Change process initiator. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to change the process initiator. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Change the current initiator of a process.
        ///
        /// Allows you to choose a user (by email or principal identifier) or an application (principal identifier).
        /// Only one option will be necessary.
        ///
        /// </remarks>
        public Response<Process> ActionsProcessChangeInitiator(Guid id, ProcessChangeInitiatorCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsProcessChangeInitiatorRequest(id, command);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsProcessSaveElementRequest(Guid id, ProcessSaveElementCommand command)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/processes/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/save-element", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(command);
            request.Content = content;
            return message;
        }

        /// <summary> Save a process element, aka: metadata. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to save an element. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Allow to save an element.
        ///
        /// If values already exist for the provided element code, it replaces them with the new ones, otherwise it creates them. The values of the previous elements that no longer exist will be deleted.
        ///
        /// If the process is already finished the invocations fails with an error.
        ///
        /// </remarks>
        public async Task<Response<Process>> ActionsProcessSaveElementAsync(Guid id, ProcessSaveElementCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsProcessSaveElementRequest(id, command);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Save a process element, aka: metadata. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to save an element. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Allow to save an element.
        ///
        /// If values already exist for the provided element code, it replaces them with the new ones, otherwise it creates them. The values of the previous elements that no longer exist will be deleted.
        ///
        /// If the process is already finished the invocations fails with an error.
        ///
        /// </remarks>
        public Response<Process> ActionsProcessSaveElement(Guid id, ProcessSaveElementCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsProcessSaveElementRequest(id, command);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsProcessDeleteElementRequest(Guid id, ProcessDeleteElementCommand command)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/processes/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/delete-element", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(command);
            request.Content = content;
            return message;
        }

        /// <summary> Delete an element by code. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to delete an element. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Allow to delete a process element by specifying the item definition code.
        ///
        /// Remove all the element values.
        ///
        /// </remarks>
        public async Task<Response<Process>> ActionsProcessDeleteElementAsync(Guid id, ProcessDeleteElementCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsProcessDeleteElementRequest(id, command);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete an element by code. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to delete an element. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Allow to delete a process element by specifying the item definition code.
        ///
        /// Remove all the element values.
        ///
        /// </remarks>
        public Response<Process> ActionsProcessDeleteElement(Guid id, ProcessDeleteElementCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsProcessDeleteElementRequest(id, command);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsProcessCompleteRequest(Guid id)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/processes/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/complete", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Complete a Process. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Complete a Process. The state of Process is set to 'completed'.
        ///
        /// If you are already in this state, no action is taken.
        ///
        /// </remarks>
        public async Task<Response<Process>> ActionsProcessCompleteAsync(Guid id, CancellationToken cancellationToken = default)
        {
            using var message = CreateActionsProcessCompleteRequest(id);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Complete a Process. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Complete a Process. The state of Process is set to 'completed'.
        ///
        /// If you are already in this state, no action is taken.
        ///
        /// </remarks>
        public Response<Process> ActionsProcessComplete(Guid id, CancellationToken cancellationToken = default)
        {
            using var message = CreateActionsProcessCompleteRequest(id);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsProcessCancelRequest(Guid id)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/processes/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/cancel", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Cancel a Process. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Cancel a Process. The Process state is set to 'cancelled'.
        ///
        /// All the active tasks will be marked as cancelled too.
        ///
        /// If you are already in this state, no action is taken.
        ///
        /// </remarks>
        public async Task<Response<Process>> ActionsProcessCancelAsync(Guid id, CancellationToken cancellationToken = default)
        {
            using var message = CreateActionsProcessCancelRequest(id);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Cancel a Process. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Cancel a Process. The Process state is set to 'cancelled'.
        ///
        /// All the active tasks will be marked as cancelled too.
        ///
        /// If you are already in this state, no action is taken.
        ///
        /// </remarks>
        public Response<Process> ActionsProcessCancel(Guid id, CancellationToken cancellationToken = default)
        {
            using var message = CreateActionsProcessCancelRequest(id);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsProcessSaveUserActionValueDocumentRequest(Guid id, string fileContentType, string fileName, Guid userActionValueId, Stream file)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/processes/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/save-user-action-value-document", false);
            uri.AppendQuery("fileContentType", fileContentType, true);
            uri.AppendQuery("fileName", fileName, true);
            uri.AppendQuery("userActionValueId", userActionValueId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/octet-stream");
            request.Content = RequestContent.Create(file);
            return message;
        }

        /// <summary> Upload and save a document in a user action. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="fileContentType"> Document content type. </param>
        /// <param name="fileName"> Document name. </param>
        /// <param name="userActionValueId"> User action value ID related to de document. </param>
        /// <param name="file"> Document to save. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileContentType"/>, <paramref name="fileName"/> or <paramref name="file"/> is null. </exception>
        /// <remarks>
        /// Allow saving a user action document uploading the content.
        ///
        /// </remarks>
        public async Task<Response<Process>> ActionsProcessSaveUserActionValueDocumentAsync(Guid id, string fileContentType, string fileName, Guid userActionValueId, Stream file, CancellationToken cancellationToken = default)
        {
            if (fileContentType == null)
            {
                throw new ArgumentNullException(nameof(fileContentType));
            }
            if (fileName == null)
            {
                throw new ArgumentNullException(nameof(fileName));
            }
            if (file == null)
            {
                throw new ArgumentNullException(nameof(file));
            }

            using var message = CreateActionsProcessSaveUserActionValueDocumentRequest(id, fileContentType, fileName, userActionValueId, file);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 304:
                    return Response.FromValue((Process)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Upload and save a document in a user action. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="fileContentType"> Document content type. </param>
        /// <param name="fileName"> Document name. </param>
        /// <param name="userActionValueId"> User action value ID related to de document. </param>
        /// <param name="file"> Document to save. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileContentType"/>, <paramref name="fileName"/> or <paramref name="file"/> is null. </exception>
        /// <remarks>
        /// Allow saving a user action document uploading the content.
        ///
        /// </remarks>
        public Response<Process> ActionsProcessSaveUserActionValueDocument(Guid id, string fileContentType, string fileName, Guid userActionValueId, Stream file, CancellationToken cancellationToken = default)
        {
            if (fileContentType == null)
            {
                throw new ArgumentNullException(nameof(fileContentType));
            }
            if (fileName == null)
            {
                throw new ArgumentNullException(nameof(fileName));
            }
            if (file == null)
            {
                throw new ArgumentNullException(nameof(file));
            }

            using var message = CreateActionsProcessSaveUserActionValueDocumentRequest(id, fileContentType, fileName, userActionValueId, file);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 304:
                    return Response.FromValue((Process)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsProcessSaveEntityDataRequest(Guid id, ProcessSaveEntityDataCommand command)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/processes/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/save-entity-data", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(command);
            request.Content = content;
            return message;
        }

        /// <summary> Save JSON data. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to save the JSON value. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Allow to save a JSON validating that the data follow the related schema. If the data is invalid, then
        /// the json form is marked as invalid.
        ///
        /// </remarks>
        public async Task<Response<Process>> ActionsProcessSaveEntityDataAsync(Guid id, ProcessSaveEntityDataCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsProcessSaveEntityDataRequest(id, command);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Save JSON data. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="command"> Command to save the JSON value. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="command"/> is null. </exception>
        /// <remarks>
        /// Allow to save a JSON validating that the data follow the related schema. If the data is invalid, then
        /// the json form is marked as invalid.
        ///
        /// </remarks>
        public Response<Process> ActionsProcessSaveEntityData(Guid id, ProcessSaveEntityDataCommand command, CancellationToken cancellationToken = default)
        {
            if (command == null)
            {
                throw new ArgumentNullException(nameof(command));
            }

            using var message = CreateActionsProcessSaveEntityDataRequest(id, command);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Process value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Process.DeserializeProcess(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsProcessSaveEntityDocumentRequest(Guid id, string fileContentType, string fileName, string schemaPath, Stream file)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/processes/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/save-entity-document", false);
            uri.AppendQuery("fileContentType", fileContentType, true);
            uri.AppendQuery("fileName", fileName, true);
            uri.AppendQuery("schemaPath", schemaPath, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/octet-stream");
            request.Content = RequestContent.Create(file);
            return message;
        }

        /// <summary> Save an entity value document. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="fileContentType"> Document content type. </param>
        /// <param name="fileName"> Document name. </param>
        /// <param name="schemaPath">
        /// JSON Schema path related to the document. The uploaded document will be validated by the passed schema path.
        ///
        /// </param>
        /// <param name="file"> Document to save. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileContentType"/>, <paramref name="fileName"/>, <paramref name="schemaPath"/> or <paramref name="file"/> is null. </exception>
        /// <remarks>
        /// Save a document in the process to later be linked into the JSON data.
        ///
        /// </remarks>
        public async Task<Response<ProcessSaveEntityDocumentResponseCommand>> ActionsProcessSaveEntityDocumentAsync(Guid id, string fileContentType, string fileName, string schemaPath, Stream file, CancellationToken cancellationToken = default)
        {
            if (fileContentType == null)
            {
                throw new ArgumentNullException(nameof(fileContentType));
            }
            if (fileName == null)
            {
                throw new ArgumentNullException(nameof(fileName));
            }
            if (schemaPath == null)
            {
                throw new ArgumentNullException(nameof(schemaPath));
            }
            if (file == null)
            {
                throw new ArgumentNullException(nameof(file));
            }

            using var message = CreateActionsProcessSaveEntityDocumentRequest(id, fileContentType, fileName, schemaPath, file);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ProcessSaveEntityDocumentResponseCommand value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ProcessSaveEntityDocumentResponseCommand.DeserializeProcessSaveEntityDocumentResponseCommand(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Save an entity value document. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="fileContentType"> Document content type. </param>
        /// <param name="fileName"> Document name. </param>
        /// <param name="schemaPath">
        /// JSON Schema path related to the document. The uploaded document will be validated by the passed schema path.
        ///
        /// </param>
        /// <param name="file"> Document to save. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="fileContentType"/>, <paramref name="fileName"/>, <paramref name="schemaPath"/> or <paramref name="file"/> is null. </exception>
        /// <remarks>
        /// Save a document in the process to later be linked into the JSON data.
        ///
        /// </remarks>
        public Response<ProcessSaveEntityDocumentResponseCommand> ActionsProcessSaveEntityDocument(Guid id, string fileContentType, string fileName, string schemaPath, Stream file, CancellationToken cancellationToken = default)
        {
            if (fileContentType == null)
            {
                throw new ArgumentNullException(nameof(fileContentType));
            }
            if (fileName == null)
            {
                throw new ArgumentNullException(nameof(fileName));
            }
            if (schemaPath == null)
            {
                throw new ArgumentNullException(nameof(schemaPath));
            }
            if (file == null)
            {
                throw new ArgumentNullException(nameof(file));
            }

            using var message = CreateActionsProcessSaveEntityDocumentRequest(id, fileContentType, fileName, schemaPath, file);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ProcessSaveEntityDocumentResponseCommand value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ProcessSaveEntityDocumentResponseCommand.DeserializeProcessSaveEntityDocumentResponseCommand(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateActionsProcessDownloadEntityDocumentRequest(Guid id, string documentUri)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/processes/", false);
            uri.AppendPath(id, true);
            uri.AppendPath("/~actions/download-entity-document", false);
            uri.AppendQuery("documentUri", documentUri, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/octet-stream, application/json");
            return message;
        }

        /// <summary> Download document. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="documentUri"> Document URI to download. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="documentUri"/> is null. </exception>
        /// <remarks> Given a process and a documentUri, download a document. </remarks>
        public async Task<Response<Stream>> ActionsProcessDownloadEntityDocumentAsync(Guid id, string documentUri, CancellationToken cancellationToken = default)
        {
            if (documentUri == null)
            {
                throw new ArgumentNullException(nameof(documentUri));
            }

            using var message = CreateActionsProcessDownloadEntityDocumentRequest(id, documentUri);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Download document. </summary>
        /// <param name="id"> The resource ID. </param>
        /// <param name="documentUri"> Document URI to download. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="documentUri"/> is null. </exception>
        /// <remarks> Given a process and a documentUri, download a document. </remarks>
        public Response<Stream> ActionsProcessDownloadEntityDocument(Guid id, string documentUri, CancellationToken cancellationToken = default)
        {
            if (documentUri == null)
            {
                throw new ArgumentNullException(nameof(documentUri));
            }

            using var message = CreateActionsProcessDownloadEntityDocumentRequest(id, documentUri);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}
